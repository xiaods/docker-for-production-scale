# 7. Java应用容器化实践

很多程序都是跑在Java虚拟机里面的，和容器的引擎概念非常类似，但具有很大的不同。我们期望JVM能顺利的跑在容器中，但是往往发现它们不能好好配合，性能受到损失。这里最主要的问题是Java无法感知容器的存在，一切都是按照物理机的信息来支持java虚拟机的环境的。当我们使用容器来运行Java应用后，容器对CPU，内存的限制是无法直接告知Java的，导致Java程序经常出现OOM Kill的问题。直到Java 10版本，JVM才开始支持Cgroup参数的配置，这些Cgroup参数让Java程序可以感知容器分配的CPU资源和RAM资源。

## 1、容器内存限制

在Java 10之前，JVM无法识别容器配置的内存限制和CPU使用限制，直到Java10开始，容器配置的内存限制可以自动加载到JVM中并执行。这里我们直观的查看Java的版本差异，以Java8和Java11作为对比参考：

```bash
$ docker container run -it -m512M --entrypoint bash openjdk:latest

$ docker-java-home/bin/java -XX:+PrintFlagsFinal -version | grep MaxHeapSize
    uintx MaxHeapSize                              := 524288000                          {product}
openjdk version "1.8.0_162"
```

从Java 6开始，JVM定义了一个服务器标准配置定义，默认服务器应该提供2个CPU和2G内存大小，并且默认配置的堆栈大小为物理内存的四分之一大小。以上例子中，虽然容器配置的512M内存限制，但是容器运行后，JVM仍然以宿主机的物理内存作为参考分配了512M内存作为堆栈大小，显然Java8并不支持容器的内存参数。作为对比的结果，我们可以看一下Java11版本的显示结果，堆栈内存被正确的配置为128M。

```text
$ docker container run -it -m512M --entrypoint bash openjdk:11-jdk
root@58e3e97ec2dd:/# docker-java-home/bin/java -XX:+PrintFlagsFinal -version | grep MaxHeapSize
   size_t MaxHeapSize                              = 134217728                                 {product} {ergonomic}
openjdk version "11.0.1" 2018-10-16
OpenJDK Runtime Environment (build 11.0.1+13-Debian-2bpo91)
OpenJDK 64-Bit Server VM (build 11.0.1+13-Debian-2bpo91, mixed mode, sharing)
```





