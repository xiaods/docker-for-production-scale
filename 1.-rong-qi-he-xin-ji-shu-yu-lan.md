# 1. 容器核心技术预览

本章讲解的容器技术并不是针对Docker工具链的技术细节的叙述。笔者讲结合实践中的疑问解惑来验证容器技术的核心思想和技术发展路线，让读者能更容易的理解容器技术的价值所在，按照业务场景合理的使用容器技术。

## 1.1 容器技术是什么

容器技术源于对PaaS平台的业务需求的不断迭代而发展起来。它是对应用环境有效隔离的技术。按照云计算平台提供的服务种类，云计算架构可以划分为三层架构，即：基础设施即服务\(IaaS\), 平台即服务 \(PaaS\), 以及软件即服务 \(SaaS\)。一般用户对IaaS层的理解就是虚拟机，而对于PaaS层的理解是应用环境。应用环境主要的任务就是对应用进程的环境隔离，容器技术在此处被大量应用。从服务体系架构的角度来看，虚拟机和容器并不是解决同一层面的问题。虚拟化更倾向于资源的虚拟化，容器技术倾向于应用环境的平台化。容器技术巧妙的借鉴了商业领域集装箱的交易模式，让软件能被彻底模块化，提高了软件交付能力。其实在早期的PaaS平台服务设计中，应用环境依赖问题一直都是PaaS无法流行起来的重要原因，让应用开发者叫苦不迭。基于这个业务痛点的触动之下，Docker公司的开发者首次提出了这项革命性技术的核心价值：构建一次，到处运行\(build once, run anywhere\)。这项技术一经推出就受到了广大用户的欢迎，在早期的技术对比中，它常常和虚拟机放在一起对比，例如下图：

![Dcoker&#x548C;&#x865A;&#x62DF;&#x673A;&#x5BF9;&#x6BD4;&#x56FE;](.gitbook/assets/docker-vs-virtual-machines.png)

Docker和虚拟机都是进程隔离技术不断发展的见证者。早在1979年Linux chroot引入之后，应用进程就可以被隔离在主机系统的任一子目录之下，避免进程修改其他进程的系统文件，保证整个系统运行的稳健性。因为Linux的多用户模式，应用进程的系统管理权限是可以突破目录隔离技术的。为了更好的隔离进程权限，对整个系统的虚拟化提出了实质的需求，虚拟机出现了。但是虚拟机对性能消耗的代价过大，让开发者再次直面应用隔离的本质，就是对进程的隔离。随着Linux Kernel技术的不断迭代发展，尤其是Namespace和Cgroup等技术的发展，让进程隔离不在局限在目录上的限制，在进程权限、进程网络、CPU核隔离等方面都达到类似虚拟机的效果，这就是容器技术的整个发展历程。

## 1.2 容器技术的价值体系

容器技术的价值在于对应用进程的标准化封装，让应用分发类似货物集装箱一样可以被任意的调度管理。标准化的封装让一切应用的运行变的简化易用。虽然这种封装技术并没有发明什么革命性的新技术，但是这种整合技术的出现是革命性的，直接推动了云计算的再次变革。从进程隔离技术的4个角度：隔离性、度量性、便携性、安全性来深入理解容器技术的价值所在。

### 2.1. 隔离性: Linux Namespace\(ns\)

每个用户实例之间相互隔离, 互不影响。 一般的硬件虚拟化方法给出的方法是 VM，而 LXC 给出的方法是 container，更细一点讲就是 kernel namespace。其中**pid、net、ipc、mnt、uts、user**等 namespace 将 container 的进程、网络、消息、文件系统、UTS\("UNIX Time-sharing System"\) 和用户空间隔离开。

#### 1\) **pid namespace**

不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 pid。所有的 LXC 进程在 docker 中的父进程为 docker 进程，每个 lxc 进程具有不同的 namespace。同时由于允许嵌套，因此可以很方便的实现 Docker in Docker。

#### 2\) **net namespace**

有了 pid namespace, 每个 namespace 中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge: docker0 连接在一起。

### 3\) **ipc namespace**

container 中进程交互还是采用 linux 常见的进程间交互方法 \(interprocess communication - IPC\), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同的是，container 的进程间交互实际上还是 host 上具有相同 pid namespace 中的进程间交互，因此需要在 IPC 资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32 位 ID。

#### 4\) **mnt namespace**

类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace 中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。

#### 5\) **uts namespace**

UTS\("UNIX Time-sharing System"\) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。

#### 6\) **user namespace**

每个 container 可以有不同的 user 和 group id, 也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户。

### 2.2 度量**性：**Control Groups \(cgroups\)

cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。groups 可以限制 blkio、cpu、cpuacct、cpuset、devices、freezer、memory、net\_cls、ns 九大子系统的资源，以下是每个子系统的详细说明：

1. blkio 这个子系统设置限制每个块设备的输入输出控制。例如: 磁盘，光盘以及 usb 等等。
2. cpu 这个子系统使用调度程序为 cgroup 任务提供 cpu 的访问。
3. cpuacct 产生 cgroup 任务的 cpu 资源报告。
4. cpuset 如果是多核心的 cpu，这个子系统会为 cgroup 任务分配单独的 cpu 和内存。
5. devices 允许或拒绝 cgroup 任务对设备的访问。
6. freezer 暂停和恢复 cgroup 任务。
7. memory 设置每个 cgroup 的内存限制以及产生内存资源报告。
8. net\_cls 标记每个网络包以供 cgroup 方便使用。
9. ns 名称空间子系统。

以上九个子系统之间也存在着一定的关系。

### 2.3 便携性: AUFS

AUFS \(AnotherUnionFS\) 是一种 Union FS, 简单来说就是支持将不同目录挂载到同一个虚拟文件系统下 \(unite several directories into a single virtual filesystem\) 的文件系统, 更进一步的理解, AUFS 支持为每一个成员目录 \(类似 Git Branch\) 设定 readonly、readwrite 和 whiteout-able 权限, 同时 AUFS 里有一个类似分层的概念, 对 readonly 权限的 branch 可以逻辑上进行修改 \(增量地, 不影响 readonly 部分的\)。通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下, 另一个更常用的就是将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起，Live CD 正是基于此方法可以允许在 OS image 不变的基础上允许用户在其上进行一些写操作。Docker 在 AUFS 上构建的 container image 也正是如此，接下来我们从启动 container 中的 linux 为例来介绍 docker 对 AUFS 特性的运用。

典型的启动 Linux 运行需要两个 FS: bootfs + rootfs:

![](.gitbook/assets/r1.png)

bootfs \(boot file system\) 主要包含 bootloader 和 kernel, bootloader 主要是引导加载 kernel, 当 boot 成功后 kernel 被加载到内存中后 bootfs 就被 umount 了. rootfs \(root file system\) 包含的就是典型 Linux 系统中的 /dev, /proc,/bin, /etc 等标准目录和文件。

对于不同的 linux 发行版, bootfs 基本是一致的, 但 rootfs 会有差别, 因此不同的发行版可以公用 bootfs 如下图:

![](.gitbook/assets/r2.png)

典型的 Linux 在启动后，首先将 rootfs 设置为 readonly, 进行一系列检查, 然后将其切换为 "readwrite" 供用户使用。在 Docker 中，初始化时也是将 rootfs 以 readonly 方式加载并检查，然而接下来利用 union mount 的方式将一个 readwrite 文件系统挂载在 readonly 的 rootfs 之上，并且允许再次将下层的 FS\(file system\) 设定为 readonly 并且向上叠加, 这样一组 readonly 和一个 writeable 的结构构成一个 container 的运行时态, 每一个 FS 被称作一个 FS 层。如下图:

![](.gitbook/assets/r3.png)

得益于 AUFS 的特性, 每一个对 readonly 层文件 / 目录的修改都只会存在于上层的 writeable 层中。这样由于不存在竞争, 多个 container 可以共享 readonly 的 FS 层。 所以 Docker 将 readonly 的 FS 层称作 "**image**" - 对于 container 而言整个 rootfs 都是 read-write 的，但事实上所有的修改都写入最上层的 writeable 层中, image 不保存用户状态，只用于模板、新建和复制使用。

![](.gitbook/assets/r4.png)

上层的 image 依赖下层的 image，因此 Docker 中把下层的 image 称作父 image，没有父 image 的 image 称作 base image。因此想要从一个 image 启动一个 container，Docker 会先加载这个 image 和依赖的父 images 以及 base image，用户的进程运行在 writeable 的 layer 中。所有 parent image 中的数据信息以及 ID、网络和 lxc 管理的资源限制等具体 container 的配置，构成一个 Docker 概念上的 container。如下图:

![](.gitbook/assets/r5.png)

### 2.4 安全性: AppArmor, SELinux

安全永远是相对的，这里有三个方面可以考虑 Docker 的安全特性:

1. 由 kernel namespaces 和 cgroups 实现的 Linux 系统固有的安全标准 ;
2. Docker Deamon 的安全接口 ;
3. Linux 本身的安全加固解决方案, 类如 AppArmor, SELinux;

## 1.3 容器技术的优缺点

## 1.4 容器技术的发展趋势





